/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.8.4. DO NOT MODIFY.
*/
`default_nettype none
`timescale 100fs/100fs
module miir1
    ( // Inputs
      input wire  clk // clock
    , input wire  rst // reset
    , input wire signed [17:0] x

      // Outputs
    , output wire signed [17:0] o
    );
  // Filters4_4_3.hs:32:1-91
  reg [179:0] c$ds_app_arg = {{18'sd8071,   -18'sd4857,   18'sd892},   {18'sd510,   18'sd1531,   18'sd1531,
                                           18'sd510},   {18'sd0,   18'sd0,
                                                         18'sd0}};
  // Filters4_4_3.hs:22:1-4
  wire [53:0] as;
  // Filters4_4_3.hs:22:1-4
  wire [71:0] bs;
  // Filters4_4_3.hs:22:1-4
  wire [53:0] regs;
  // Filters4_4_3.hs:22:1-4
  wire [71:0] bProds;
  wire signed [17:0] c$result_rec;
  wire signed [17:0] c$case_alt;
  wire [17:0] \r' ;
  wire [18:0] \c$r'_app_arg ;
  wire signed [18:0] r;
  // Filters4_4_3.hs:22:1-4
  wire [53:0] abSums;
  wire [35:0] c$app_arg;
  // Filters4_4_3.hs:22:1-4
  wire [53:0] c$abSums_app_arg;
  wire [71:0] c$vec2;
  wire [17:0] c$bv_1;
  wire [17:0] c$bv_2;
  wire [17:0] c$bv_3;
  wire [18:0] \r'_projection ;
  wire [53:0] c$vec1;
  wire [35:0] c$vec1_0;
  wire [35:0] c$vec2_0;
  wire [53:0] c$vec2_1;

  // register begin
  always @(posedge clk or  posedge  rst) begin : c$ds_app_arg_register
    if ( rst) begin
      c$ds_app_arg <= {{18'sd8071,   -18'sd4857,   18'sd892},   {18'sd510,   18'sd1531,   18'sd1531,
                                             18'sd510},   {18'sd0,   18'sd0,
                                                           18'sd0}};
    end else begin
      c$ds_app_arg <= {as,   bs,   {c$app_arg,$signed(abSums[18-1:0])}};
    end
  end
  // register end

  assign as = c$ds_app_arg[179:126];

  assign bs = c$ds_app_arg[125:54];

  assign regs = c$ds_app_arg[53:0];

  assign c$vec2 = ({4 {x}});

  // zipWith start
  genvar i;
  generate
  for (i = 0; i < 4; i = i + 1) begin : zipWith
    wire signed [17:0] zipWith_in1;
    assign zipWith_in1 = bs[i*18+:18];
    wire signed [17:0] zipWith_in2;
    assign zipWith_in2 = c$vec2[i*18+:18];
    wire signed [17:0] c$n;
    wire signed [17:0] result;
    wire signed [17:0] c$case_alt_0;
    wire [5:0] c$app_arg_0;
    wire [4:0] c$app_arg_1;
    wire [4:0] rL;
    wire [30:0] rR;
    wire [35:0] ds3;
    wire signed [35:0] c$ds3_app_arg;
    wire [30:0] c$bv;
    wire [30:0] c$bv_0;
    assign c$n = result;

    assign c$bv = (rR >> (64'sd13));

    assign result = (((~ (| (c$app_arg_0))) | (& (c$app_arg_0))) == 1'b1) ? ($signed((c$bv[0+:18]))) : c$case_alt_0;

    assign c$case_alt_0 = (( c$app_arg_1[5-1] ) == 1'b0) ? 18'sd131071 : -18'sd131072;

    assign c$bv_0 = (rR);

    assign c$app_arg_0 = ({((( c$bv_0[31-1] ))),c$app_arg_1});

    assign c$app_arg_1 = rL;

    assign rL = ds3[35:31];

    assign rR = ds3[30:0];

    assign ds3 = (($unsigned(c$ds3_app_arg)));

    assign c$ds3_app_arg = zipWith_in1 * zipWith_in2;


    assign bProds[i*18+:18] = c$n;
  end
  endgenerate
  // zipWith end

  assign c$bv_1 = (\r' );

  assign c$result_rec = ((( \c$r'_app_arg [19-1] ) ^ ( c$bv_1[18-1] )) == 1'b0) ? ($signed(\r' )) : c$case_alt;

  assign c$bv_2 = (($unsigned(($signed(regs[54-1 -: 18])))));

  assign c$bv_3 = (($unsigned(($signed(bProds[72-1 -: 18])))));

  assign c$case_alt = ((( c$bv_2[18-1] ) & ( c$bv_3[18-1] )) == 1'b0) ? 18'sd131071 : -18'sd131072;

  assign \r'_projection  = \c$r'_app_arg ;

  assign \r'  = \r'_projection [17:0];

  assign \c$r'_app_arg  = ($unsigned(r));

  assign r = ($signed(regs[54-1 -: 18])) + ($signed(bProds[72-1 -: 18]));

  assign c$vec1 = (bProds[54-1 : 0]);

  // zipWith start
  genvar i_0;
  generate
  for (i_0 = 0; i_0 < 3; i_0 = i_0 + 1) begin : zipWith_0
    wire signed [17:0] zipWith_in1_0;
    assign zipWith_in1_0 = c$vec1[i_0*18+:18];
    wire signed [17:0] zipWith_in2_0;
    assign zipWith_in2_0 = c$abSums_app_arg[i_0*18+:18];
    wire signed [17:0] c$n_0;
    wire signed [17:0] result_3;
    wire signed [17:0] c$case_alt_4;
    wire [17:0] \r'_1 ;
    wire [18:0] \c$r'_app_arg_0 ;
    wire signed [18:0] r_0;
    wire [17:0] c$bv_4;
    wire [17:0] c$bv_5;
    wire [17:0] c$bv_6;
    wire [18:0] \r'_projection_0 ;
    assign c$n_0 = result_3;

    assign c$bv_4 = (\r'_1 );

    assign result_3 = ((( \c$r'_app_arg_0 [19-1] ) ^ ( c$bv_4[18-1] )) == 1'b0) ? ($signed(\r'_1 )) : c$case_alt_4;

    assign c$bv_5 = (($unsigned(zipWith_in1_0)));

    assign c$bv_6 = (($unsigned(zipWith_in2_0)));

    assign c$case_alt_4 = ((( c$bv_5[18-1] ) & ( c$bv_6[18-1] )) == 1'b0) ? 18'sd131071 : -18'sd131072;

    assign \r'_projection_0  = \c$r'_app_arg_0 ;

    assign \r'_1  = \r'_projection_0 [17:0];

    assign \c$r'_app_arg_0  = ($unsigned(r_0));

    assign r_0 = zipWith_in1_0 + zipWith_in2_0;


    assign abSums[i_0*18+:18] = c$n_0;
  end
  endgenerate
  // zipWith end

  assign c$vec1_0 = (abSums[54-1 : 18]);

  assign c$vec2_0 = (regs[36-1 : 0]);

  // zipWith start
  genvar i_1;
  generate
  for (i_1 = 0; i_1 < 2; i_1 = i_1 + 1) begin : zipWith_1
    wire signed [17:0] zipWith_in1_1;
    assign zipWith_in1_1 = c$vec1_0[i_1*18+:18];
    wire signed [17:0] zipWith_in2_1;
    assign zipWith_in2_1 = c$vec2_0[i_1*18+:18];
    wire signed [17:0] c$n_1;
    wire signed [17:0] result_4;
    wire signed [17:0] c$case_alt_5;
    wire [17:0] \r'_2 ;
    wire [18:0] \c$r'_app_arg_1 ;
    wire signed [18:0] r_1;
    wire [17:0] c$bv_7;
    wire [17:0] c$bv_8;
    wire [17:0] c$bv_9;
    wire [18:0] \r'_projection_1 ;
    assign c$n_1 = result_4;

    assign c$bv_7 = (\r'_2 );

    assign result_4 = ((( \c$r'_app_arg_1 [19-1] ) ^ ( c$bv_7[18-1] )) == 1'b0) ? ($signed(\r'_2 )) : c$case_alt_5;

    assign c$bv_8 = (($unsigned(zipWith_in1_1)));

    assign c$bv_9 = (($unsigned(zipWith_in2_1)));

    assign c$case_alt_5 = ((( c$bv_8[18-1] ) & ( c$bv_9[18-1] )) == 1'b0) ? 18'sd131071 : -18'sd131072;

    assign \r'_projection_1  = \c$r'_app_arg_1 ;

    assign \r'_2  = \r'_projection_1 [17:0];

    assign \c$r'_app_arg_1  = ($unsigned(r_1));

    assign r_1 = zipWith_in1_1 + zipWith_in2_1;


    assign c$app_arg[i_1*18+:18] = c$n_1;
  end
  endgenerate
  // zipWith end

  assign c$vec2_1 = ({3 {c$result_rec}});

  // zipWith start
  genvar i_2;
  generate
  for (i_2 = 0; i_2 < 3; i_2 = i_2 + 1) begin : zipWith_2
    wire signed [17:0] zipWith_in1_2;
    assign zipWith_in1_2 = as[i_2*18+:18];
    wire signed [17:0] zipWith_in2_2;
    assign zipWith_in2_2 = c$vec2_1[i_2*18+:18];
    wire signed [17:0] c$n_2;
    wire signed [17:0] result_5;
    wire signed [17:0] c$case_alt_6;
    wire [5:0] c$app_arg_2;
    wire [4:0] c$app_arg_3;
    wire [4:0] rL_1;
    wire [30:0] rR_1;
    wire [35:0] ds3_0;
    wire signed [35:0] c$ds3_app_arg_0;
    wire [30:0] c$bv_10;
    wire [30:0] c$bv_11;
    assign c$n_2 = result_5;

    assign c$bv_10 = (rR_1 >> (64'sd13));

    assign result_5 = (((~ (| (c$app_arg_2))) | (& (c$app_arg_2))) == 1'b1) ? ($signed((c$bv_10[0+:18]))) : c$case_alt_6;

    assign c$case_alt_6 = (( c$app_arg_3[5-1] ) == 1'b0) ? 18'sd131071 : -18'sd131072;

    assign c$bv_11 = (rR_1);

    assign c$app_arg_2 = ({((( c$bv_11[31-1] ))),c$app_arg_3});

    assign c$app_arg_3 = rL_1;

    assign rL_1 = ds3_0[35:31];

    assign rR_1 = ds3_0[30:0];

    assign ds3_0 = (($unsigned(c$ds3_app_arg_0)));

    assign c$ds3_app_arg_0 = zipWith_in1_2 * zipWith_in2_2;


    assign c$abSums_app_arg[i_2*18+:18] = c$n_2;
  end
  endgenerate
  // zipWith end

  assign o = c$result_rec;


endmodule

