/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.8.4. DO NOT MODIFY.
*/
`default_nettype none
`timescale 100fs/100fs
module fir1_6
    ( // Inputs
      input wire  xs // clock
    , input wire  rst // reset
    , input wire signed [7:0] eta

      // Outputs
    , output wire signed [7:0] o
    );
  // Filters1_6.hs:16:1-86
  reg signed [7:0] reg1 = 8'sd0;
  // Filters1_6.hs:16:1-86
  reg signed [7:0] reg2 = 8'sd0;
  // Filters1_6.hs:16:1-86
  reg signed [7:0] reg3 = 8'sd0;
  // Filters1_6.hs:16:1-86
  reg signed [7:0] reg4 = 8'sd0;
  // Filters1_6.hs:16:1-86
  reg signed [7:0] reg5 = 8'sd0;
  // Filters1_6.hs:16:1-86
  wire [47:0] x;
  wire [47:0] c$app_arg;
  // Filters1_6.hs:16:1-86
  reg signed [7:0] c$x_app_arg = 8'sd0;
  wire [47:0] c$vec1;

  // register begin
  always @(posedge xs or  posedge  rst) begin : reg1_register
    if ( rst) begin
      reg1 <= 8'sd0;
    end else begin
      reg1 <= eta;
    end
  end
  // register end

  // register begin
  always @(posedge xs or  posedge  rst) begin : reg2_register
    if ( rst) begin
      reg2 <= 8'sd0;
    end else begin
      reg2 <= reg1;
    end
  end
  // register end

  // register begin
  always @(posedge xs or  posedge  rst) begin : reg3_register
    if ( rst) begin
      reg3 <= 8'sd0;
    end else begin
      reg3 <= reg2;
    end
  end
  // register end

  // register begin
  always @(posedge xs or  posedge  rst) begin : reg4_register
    if ( rst) begin
      reg4 <= 8'sd0;
    end else begin
      reg4 <= reg3;
    end
  end
  // register end

  // register begin
  always @(posedge xs or  posedge  rst) begin : reg5_register
    if ( rst) begin
      reg5 <= 8'sd0;
    end else begin
      reg5 <= reg4;
    end
  end
  // register end

  assign x = {c$x_app_arg,   reg5,   reg4,
              reg3,   reg2,   reg1};

  wire [47:0] vec;
  wire signed [7:0] acc_3_0;
  wire signed [7:0] acc_1;
  wire signed [7:0] acc_2;
  wire signed [7:0] acc_3;
  wire signed [7:0] acc_4;
  wire signed [7:0] acc_5;
  wire signed [7:0] acc_6;
  wire signed [7:0] acc_1_0;
  wire signed [7:0] acc_1_1;
  wire signed [7:0] acc_2_0;
  wire signed [7:0] acc_1_2;
  assign o = acc_3_0;

  assign vec = c$app_arg;

  assign acc_1 = $signed(vec[47:40]);

  assign acc_2 = $signed(vec[39:32]);

  assign acc_3 = $signed(vec[31:24]);

  assign acc_4 = $signed(vec[23:16]);

  assign acc_5 = $signed(vec[15:8]);

  assign acc_6 = $signed(vec[7:0]);

  assign acc_1_0 = acc_1 + acc_2;



  assign acc_1_1 = acc_3 + acc_4;



  assign acc_1_2 = acc_5 + acc_6;



  assign acc_2_0 = acc_1_0 + acc_1_1;



  assign acc_3_0 = acc_2_0 + acc_1_2;





  assign c$vec1 = {8'sd3,   8'sd5,   8'sd7,
                   8'sd11,   8'sd13,   8'sd17};

  // zipWith start
  genvar i;
  generate
  for (i = 0; i < 6; i = i + 1) begin : zipWith
    wire signed [7:0] zipWith_in1;
    assign zipWith_in1 = c$vec1[i*8+:8];
    wire signed [7:0] zipWith_in2;
    assign zipWith_in2 = x[i*8+:8];
    wire signed [7:0] c$n;
    assign c$n = zipWith_in1 * zipWith_in2;


    assign c$app_arg[i*8+:8] = c$n;
  end
  endgenerate
  // zipWith end

  // register begin
  always @(posedge xs or  posedge  rst) begin : c$x_app_arg_register
    if ( rst) begin
      c$x_app_arg <= 8'sd0;
    end else begin
      c$x_app_arg <= reg5;
    end
  end
  // register end


endmodule

